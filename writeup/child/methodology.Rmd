Let $\theta_1, \theta_2, \dots, \theta_K$ be the true parameter values and $\hat \theta_1, \hat \theta_2, \dots, \hat \theta_K$ be the estimates obtained.

## Parametric bootstrap

Let $\hat \theta_1, \hat \theta_2, \dots, \hat \theta_K$ be independent but not identically distributed estimates. For this study, it is assumed that $\hat{\theta}_k \sim N \left(\theta_k, \sigma_k^2 \right)$, $k = 1, 2, \dots, K$, where $\sigma^2_k$ is known. Denote the corresponding ordered values by $\hat \theta_{(1)}, \hat \theta_{(2)}, \dots, \hat \theta_{(K)}$.


\begin{algorithm}[H]
	\caption{Computation of Joint Confidence Region via Parametric Bootstrap} 
	\label{alg:parametricbs_ci}
	\begin{algorithmic}[1]
		\For {$b = 1, 2, \dots, B$}
				\State Generate $\hat\theta^*_{bk} \sim N \left( \hat\theta_k, \sigma_k^2 \right)$, $i = 1, 2, \dots, K$ and let $\hat{\theta}_{b(1)}, \hat{\theta}_{b(2)}, \dots, \hat{\theta}_{b(K)}$ be the corresponding ordered values
		    \Statex \begin{minipage}{\linewidth}
          \centering
          \begin{tabular}{|c|c|c|c|c|}
            \hline
             & $k = 1$ & $k = 2$ & $\dots$ & $k = K$ \\
            \hline
            $b = 1$ & $\hat{\theta}^*_{1(1)}$ & $\hat{\theta}^*_{1(2)}$ & \dots & $\hat{\theta}^*_{1(K)}$ \\
            \hline
            $b = 2$ & $\hat{\theta}^*_{2(1)}$ & $\hat{\theta}^*_{2(2)}$ & \dots & $\hat{\theta}^*_{2(K)}$ \\
            \hline
            $\vdots$ & \vdots & \vdots & \dots & \vdots\\
            \hline
            $b = B$ & $\hat{\theta}^*_{B(1)}$ & $\hat{\theta}^*_{B(2)}$ & \dots & $\hat{\theta}^*_{B(K)}$ \\
            \hline
          \end{tabular}
        \end{minipage}
        \State Compute 
        \Statex \begin{minipage}{\linewidth}
        \centering
$\hat\sigma^*_{b(k)} = \sqrt{\text{kth ordered value among} \ \left\{ \hat{\theta}^{*2}_{b1} + \sigma_1^2, \hat{\theta}^{*2}_{b2} + \sigma_2^2, \dots, \hat{\theta}^{*2}_{bK} + \sigma_K^2 \right\} - \hat {\theta}^{*2}_{(k)}}$
        \end{minipage}
				\State Compute $t^*_b = \underset{1 \leq k \leq K}{\max} \Bigg| \frac{\hat\theta^*_{b(k)} - \hat\theta^*_{k}}{\sigma^*_{b(k)}} \Bigg|$
		\EndFor
		\State Compute the $\left(1-\alpha\right)$-sample quantile of $t^*_1, t^*_2, \dots, t^*_B$, call this $\hat{t}$.
		\State The joint confidence region of $\theta_{(1)}, \theta_{(2)}, \dots, \theta_{(K)}$ is given by 
		\Statex \begin{minipage}{\linewidth}
    \centering
$\mathfrak{R} = \left[ \hat\theta_{(1)} \pm \hat t \times \hat\sigma_{(1)}  \right] \times \left[ \hat\theta_{(2)} \pm \hat t \times \hat\sigma_{(2)}  \right] \times \dots \times \left[ \hat\theta_{(K)} \pm \hat t \times \hat\sigma_{(K)}  \right]$
    \end{minipage}
		 where $\hat \sigma_{(k)}$ is computed as
		\Statex \begin{minipage}{\linewidth}
    \centering
$\hat\sigma_{(k)} = \sqrt{\text{kth ordered value among} \ \left\{ \hat{\theta}^{2}_{1} + \sigma_1^2, \hat{\theta}^{2}_{2} + \sigma_2^2, \dots, \hat{\theta}^{2}_{K} + \sigma_K^2 \right\} - \hat {\theta}^{2}_{(k)}}$
\end{minipage}
	\end{algorithmic} 
\end{algorithm}


Algorithm \ref{alg:parametricbs_cov} is used to calculate the coverage which is defined as the proportion of times that the true parameter values fall within the confidence interval for all $K$ simultaneously. Ideally, this should be equal to $0.90$ since $\alpha = 0.1$. It also calculates the average $T_1, T_2,$ and $T_3$. Higher values of $T_1$ and $T_2$ indicate wider confidence intervals and are therefore less desirable, whereas higher values of $T_3$ are preferable.

\begin{algorithm}[H]
	\caption{Computation of Coverage Probability for Parametric Bootstrap} 
	\label{alg:parametricbs_cov}
	For given values of $\theta_1, \theta_2, \dots, \theta_K$ and thus $\theta_{(1)}, \theta_{(2)}, \dots, \theta_{(K)}$
	\begin{algorithmic}[1] % Start algorithmic block
			\For {$\text{replications} = 1, 2, \dots, 5000$}
    		\State Generate $\hat\theta_k \sim N(\theta_k, \sigma^2_k)$, for $k = 1, 2, \dots, K$
    		\State Compute the rectangular confidence region $\mathfrak{R}$ using Algorithm \ref{alg:parametricbs_ci}.
    		\State Check if $\left( \theta_{(1)}, \theta_{(2)}, \dots, \theta_{(K)}\right) \in \mathfrak{R}$ and compute 
    		\Statex \begin{minipage}{\linewidth}
        \centering
    		$T_1 = \frac{1}{K} \sum^K_{k=1} \Big | \Lambda_{Ok} \Big|$\\
    		$T_2 = \prod^K_{k=1} \Big | \Lambda_{Ok} \Big|$\\
    		$T_3 = 1 - \frac{K + \sum^K_{k=1} \big | \Lambda_{Ok} \big|}{K^2}$\\
    		\end{minipage}
    	\EndFor
    \State Compute the proportion of times that the condition in step 4 is satisfied and the average of $T_1, T_2$, and $T_3$.
	\end{algorithmic} % End algorithmic block
\end{algorithm}


## Nonrank-based method

The nonrank-based method assumes that $\boldsymbol{\hat\theta} = \left(\hat\theta_1, \hat\theta_2, \dots, \hat\theta_K\right) \sim N \left( \boldsymbol{\theta}, \boldsymbol{\Sigma}\right)$. It accounts for potential correlation among items being ranked. For this case, an exchangeable correlation, $\boldsymbol{\rho}$ (See Equation \ref{eq:equicorrelation}.), is assumed and used in the calculation of the variance covariance matrix (See Equation \ref{eq:sigma_matrix}.).

\begin{equation}
  \boldsymbol{\rho} = \left( 1-\rho \right) \mathbf{I}_K + \rho \boldsymbol{1}_K \boldsymbol{1}'_K
  \label{eq:equicorrelation}
\end{equation}


\begin{equation}
  \boldsymbol{\Sigma} = \boldsymbol{\Delta}^{1/2} \boldsymbol{\rho} \boldsymbol{\Delta}^{1/2}
  \label{eq:sigma_matrix}
\end{equation}

where $\boldsymbol{\Delta} = \text{diag} \left\{ \sigma^2_1, \sigma^2_2, \dots, \sigma^2_K \right\}$, with known $\sigma_k$'s and $\rho$ is studied for $0.1, 0.5, 0.9$.

\begin{algorithm}[H]
	\caption{Computation of Joint Confidence Region via Nonrank-based Method} 
	\label{alg:nonrank_ci}
	Let the data consist of $\hat \theta_1, \dots, \hat \theta_K$ and suppose $\boldsymbol{\Sigma}$ is known
	\begin{algorithmic}[1]
		\For {$b = 1, 2, \dots, B$}
				\State Generate $\boldsymbol{\hat\theta}^*_b \sim N_K \left( \boldsymbol{\hat\theta}, \boldsymbol{\Sigma}\right)$ and write $\boldsymbol{\hat\theta}^*_b = \left( \hat\theta^*_{b1}, \hat\theta^*_{b2}, \dots, \hat\theta^*_{bK} \right)' $
				\State Compute $t^*_b = \underset{1 \leq j \leq K}{\max} \Bigg| \frac{\hat\theta^*_{bj} - \hat\theta^*_{j}}{\sigma_j} \Bigg|$
		\EndFor
		\State Compute the $\left(1-\alpha\right)$-sample quantile of $t^*_1, t^*_2, \dots, t^*_B$, call this $\hat{t}$.
		\State The joint confidence region of $\theta_1, \theta_2, \dots, \theta_K$ is given by 
		\Statex \begin{minipage}{\linewidth}
    \centering
$\mathfrak{R} = \left[ \hat\theta_1 \pm \hat t \times \sigma_1  \right] \times \left[ \hat\theta_2 \pm \hat t \times \sigma_2  \right] \times \dots \times \left[ \hat\theta_K \pm \hat t \times \sigma_K  \right]$
    \end{minipage}
	\end{algorithmic} 
\end{algorithm}




Algorithm \ref{alg:nonrank_cov} is similar to Algorithm \ref{alg:parametricbs_cov} but computes for the coverage and average $T_1, T_2,$ and $T_3$ for the nonrank-based method.

\begin{algorithm}[H]
	\caption{Computation of Coverage Probability for Nonrank-based Method} 
	\label{alg:nonrank_cov}
	For given values of $\theta_1, \theta_2, \dots, \theta_K$ and $\boldsymbol{\Sigma}$
	\begin{algorithmic}[1] % Start algorithmic block
			\For {$\text{replications} = 1, 2, \dots, 5000$}
    		\State Generate $\boldsymbol{\hat\theta} \sim N_K(\boldsymbol{\theta}, \boldsymbol{\Sigma})$
    		\State Compute the rectangular confidence region $\mathfrak{R}$ using Algorithm \ref{alg:nonrank_ci}.
    		\State Check if $\left( \theta_1, \theta_2, \dots, \theta_K\right) \in \mathfrak{R}$ and compute $T_1, T_2$, and $T_3$.
    	\EndFor
    \State Compute the proportion of times that the condition in step 4 is satisfied and the average of $T_1, T_2$, and $T_3$.
	\end{algorithmic} % End algorithmic block
\end{algorithm}

## Results


```{r echo = FALSE}
library("gtsummary")
load("../results/simulation_results.RData")

withcorr_nonrank <- results
#compare <- results1

load("../results/simulation_results_ocorr.RData")

with0corr_nonrank <- results
parametric <- results1
```


For the simulation studies, $\alpha$ is fixed at $0.1$, while the true standard deviations are varied ($sd = 2.0, 3.6, 6.0$) along with the number of items to be ranked ($K = 5, 10, 20, 30, 40, 51$). Table \@ref(tab:coverage) shows that when the correlation is zero, the nonrank-based, independent, and Bonferroni CI methodology exhibit similar coverage values regardless of $K$ and $sd$. In contrast, the parametric approach generally yields higher coverage for smaller $sd$ while showing comparable variability across different $K$. It deviates the most from the nominal coverage level.



```{r coverage}
library(knitr)
library(kableExtra)
library(gt)
library(dplyr)

out <- with0corr_nonrank %>% left_join(parametric, by = c("K", "sd"))

# out %>% select(c(K, sd, Cov_parametric, Cov_nonrankbased, Cov_independent, Cov_bonferroni)) %>% gt() |>
#   tab_options(latex.use_longtable = TRUE)


out %>%
  select(K, sd, Cov_parametric, Cov_nonrankbased, Cov_independent, Cov_bonferroni) %>%
  arrange(K, sd) %>%
  kable("latex", booktabs = TRUE, longtable = FALSE, 
        col.names = c("K", "sd", "Parametric", "Nonrank-based", "Independent", "Bonferroni"),
        caption = "Simulation results for coverage probabilities when $\\rho = 0$.") %>%
  kable_styling(latex_options = c("repeat_header","hold_position")) %>%
  collapse_rows(columns = 1, latex_hline = "major") %>%   # <-- merges K column
  add_header_above(c(" " = 2, "Coverage" = 4))             # spanner over techniques
```


The case is different in terms of $T_1$ (See Table \@ref(tab:T1).) as it increases with decreasing $sd$ and increasing $K$. The CIs are wider for the parametric approach compared to the remaining approaches whose $T_1$ only vary by a small margin, with nonrank-based method having the smallest $T_1$ and Bonferroni, the largest one. The same behavior is observed for $T_2$ and $T_3$.


```{r T1}
out <- with0corr_nonrank %>% left_join(parametric, by = c("K", "sd"))

out %>%
  select(K, sd, T1_parametric, T1_nonrankbased, T1_independent, T1_bonferroni) %>%
  arrange(K, sd) %>%
  kable("latex", booktabs = TRUE, longtable = FALSE,
        col.names = c("K", "sd", "Parametric", "Nonrank-based", "Independent", "Bonferroni"),
        caption = "Simulation results for average $T_1$ when $\\rho = 0$.") %>%
  kable_styling(latex_options = "repeat_header") %>%
  collapse_rows(columns = 1, latex_hline = "major") %>%
  add_header_above(c(" " = 2, "$T_1$" = 4), escape = FALSE)
```



As the correlation increases, the coverage of both independent and Bonferroni CIs exceeds the nominal value while that of nonrank-based method remains close to it. This holds regardless of $K$ and $sd$. See Table \@ref(tab:nonzerocorrel) for $sd=2.0$; results for other $sd$ values are omitted, as they are identical to those shown. This suggests that when items being ranked are correlated, the proposed method is preferable, as it maintains coverage close to the nominal level. 

```{r nonzerocorrel}
out <- withcorr_nonrank %>% filter(sd == 2.0)
out %>%
  select(corr, K, Cov_nonrankbased, Cov_independent, Cov_bonferroni) %>%
  arrange(corr, K) %>%
  kable("latex", booktabs = TRUE, longtable = FALSE,
        col.names = c("corr","K", "Nonrank-based", "Independent", "Bonferroni"),
        caption = "Simulation results for coverage probabilities when $\\rho \\neq 0$.") %>%
  kable_styling(latex_options = c("repeat_header","hold_position")) %>%
  collapse_rows(columns = 1, latex_hline = "major") %>%   # <-- merges K column
  add_header_above(c(" " = 2, "Coverage" = 3))             # spanner over techniques
```

$sd$ remains to be the quantity that affects $T_1$ as it only differs by a small amount with changes in $\rho$. This is shown in Table \@ref(tab:nonzerocorrelt1).


```{r nonzerocorrelt1}
out <- withcorr_nonrank
df_wide <- out %>%
  select(corr, K, sd, T1_nonrankbased, T1_independent, T1_bonferroni) %>%
  tidyr::pivot_wider(
    names_from = corr,
    values_from = c(T1_nonrankbased, T1_independent, T1_bonferroni),
    names_glue = "{corr}_{.value}"
  ) %>%
  arrange(K, sd)

v<- names(df_wide)
names(df_wide) <- c(names(df_wide)[1:2] , paste0("$\\rho = $ ", sub("_.*", "", names(df_wide)[3:length(v)])))

df_wide %>%
  kable("latex", booktabs = TRUE, longtable = FALSE, escape = FALSE,
        caption = "Simulation results for $T_1$ probabilities when $\\rho \\neq 0$.") %>%
  kable_styling(latex_options = "repeat_header","hold_position") %>%
  collapse_rows(columns = 1:2, latex_hline = "major") %>%
  add_header_above(c(" " = 2,
                     "Nonrank-based" = 3,
                     "Independent" = 3,
                     "Bonferroni" = 3)) %>%
  add_header_above(c(" " = 2, "$T_1$" = 9), escape = FALSE) %>%
  landscape()

```



